<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Data Warehouse Studio</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.3.0/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { margin: 0; font-family: 'Arial', sans-serif; }
        .cube-container { position: relative; }
        .dimension-label { position: absolute; color: white; font-weight: bold; background: rgba(0,0,0,0.7); padding: 4px 8px; border-radius: 4px; }
        .operations-panel { backdrop-filter: blur(10px); background: rgba(0,0,0,0.1); }
        .glass-panel { backdrop-filter: blur(16px); background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); }
    </style>
</head>
<body class="bg-gradient-to-br from-gray-900 via-blue-900 to-purple-900 text-white min-h-screen">
    
    <!-- Header -->
    <header class="bg-black bg-opacity-50 p-4 border-b border-gray-700">
        <div class="flex items-center justify-between">
            <h1 class="text-2xl font-bold text-blue-400">üìä 3D Data Warehouse Studio</h1>
            <div class="flex gap-4">
                <input type="file" id="csvFile" accept=".csv" class="hidden">
                <button onclick="document.getElementById('csvFile').click()" 
                        class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg transition-all duration-300 transform hover:scale-105">
                    üìÅ Import CSV
                </button>
                <button onclick="generateSampleData()" 
                        class="bg-green-600 hover:bg-green-700 px-4 py-2 rounded-lg transition-all duration-300 transform hover:scale-105">
                    üé≤ Sample Data
                </button>
            </div>
        </div>
    </header>

    <div class="flex h-screen">
        
        <!-- Left Panel - Controls -->
        <div class="w-80 p-4 operations-panel border-r border-gray-700 overflow-y-auto">
            
            <!-- Data Source Info -->
            <div class="glass-panel p-4 rounded-lg mb-4">
                <h3 class="text-lg font-semibold mb-2 text-blue-300">üìà Data Source</h3>
                <div id="dataInfo" class="text-sm text-gray-300">
                    No data loaded. Import a CSV file or generate sample data.
                </div>
            </div>

            <!-- Cube Dimensions -->
            <div class="glass-panel p-4 rounded-lg mb-4">
                <h3 class="text-lg font-semibold mb-2 text-green-300">üéØ Dimensions</h3>
                <div class="space-y-2">
                    <div>
                        <label class="block text-sm font-medium mb-1">X-Axis:</label>
                        <select id="xDimension" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-1 text-sm">
                            <option value="">Select dimension...</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-1">Y-Axis:</label>
                        <select id="yDimension" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-1 text-sm">
                            <option value="">Select dimension...</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-1">Z-Axis:</label>
                        <select id="zDimension" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-1 text-sm">
                            <option value="">Select dimension...</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium mb-1">Measure:</label>
                        <select id="measure" class="w-full bg-gray-800 border border-gray-600 rounded px-3 py-1 text-sm">
                            <option value="">Select measure...</option>
                        </select>
                    </div>
                </div>
                <button onclick="updateCube()" 
                        class="w-full mt-3 bg-purple-600 hover:bg-purple-700 px-3 py-2 rounded text-sm transition-all">
                    üîÑ Update Cube
                </button>
            </div>

            <!-- Data Operations -->
            <div class="glass-panel p-4 rounded-lg mb-4">
                <h3 class="text-lg font-semibold mb-2 text-yellow-300">‚öôÔ∏è Operations</h3>
                <div class="grid grid-cols-2 gap-2">
                    <button onclick="performSlice()" class="bg-red-600 hover:bg-red-700 px-3 py-2 rounded text-sm transition-all">
                        üî™ Slice
                    </button>
                    <button onclick="performDice()" class="bg-orange-600 hover:bg-orange-700 px-3 py-2 rounded text-sm transition-all">
                        üé≤ Dice
                    </button>
                    <button onclick="performDrillDown()" class="bg-yellow-600 hover:bg-yellow-700 px-3 py-2 rounded text-sm transition-all">
                        ‚¨áÔ∏è Drill Down
                    </button>
                    <button onclick="performDrillUp()" class="bg-green-600 hover:bg-green-700 px-3 py-2 rounded text-sm transition-all">
                        ‚¨ÜÔ∏è Drill Up
                    </button>
                    <button onclick="performPivot()" class="bg-blue-600 hover:bg-blue-700 px-3 py-2 rounded text-sm transition-all">
                        üîÑ Pivot
                    </button>
                    <button onclick="performRollUp()" class="bg-indigo-600 hover:bg-indigo-700 px-3 py-2 rounded text-sm transition-all">
                        üìä Roll Up
                    </button>
                </div>
            </div>

            <!-- Filters -->
            <div class="glass-panel p-4 rounded-lg mb-4">
                <h3 class="text-lg font-semibold mb-2 text-pink-300">üîç Filters</h3>
                <div id="filterControls" class="space-y-2">
                    <!-- Dynamic filter controls will be added here -->
                </div>
            </div>

            <!-- Analysis Tools -->
            <div class="glass-panel p-4 rounded-lg">
                <h3 class="text-lg font-semibold mb-2 text-cyan-300">üìä Analysis</h3>
                <div class="grid grid-cols-1 gap-2">
                    <button onclick="showChart('bar')" class="bg-cyan-600 hover:bg-cyan-700 px-3 py-2 rounded text-sm transition-all">
                        üìä Bar Chart
                    </button>
                    <button onclick="showChart('line')" class="bg-teal-600 hover:bg-teal-700 px-3 py-2 rounded text-sm transition-all">
                        üìà Line Chart
                    </button>
                    <button onclick="showChart('pie')" class="bg-purple-600 hover:bg-purple-700 px-3 py-2 rounded text-sm transition-all">
                        ü•ß Pie Chart
                    </button>
                    <button onclick="showStatistics()" class="bg-indigo-600 hover:bg-indigo-700 px-3 py-2 rounded text-sm transition-all">
                        üìã Statistics
                    </button>
                </div>
            </div>
        </div>

        <!-- Main Content Area -->
        <div class="flex-1 flex flex-col">
            
            <!-- Cube Visualization -->
            <div class="flex-1 relative">
                <div id="cubeContainer" class="w-full h-full cube-container"></div>
                <div id="cubeLabels"></div>
                
                <!-- Cube Controls -->
                <div class="absolute top-4 right-4 glass-panel p-3 rounded-lg">
                    <h4 class="font-semibold mb-2 text-blue-300">üéÆ Controls</h4>
                    <div class="text-xs space-y-1 text-gray-300">
                        <div>üñ±Ô∏è Click & Drag: Rotate</div>
                        <div>üîç Scroll: Zoom</div>
                        <div>üì¶ Click Cube: Select</div>
                    </div>
                </div>
            </div>

            <!-- Bottom Panel -->
            <div class="h-80 border-t border-gray-700 flex">
                
                <!-- Data Table -->
                <div class="flex-1 p-4">
                    <h3 class="text-lg font-semibold mb-2 text-green-300">üìã Data View</h3>
                    <div id="dataTable" class="bg-black bg-opacity-30 rounded-lg overflow-auto h-60 text-sm">
                        <div class="p-4 text-gray-400 text-center">No data to display</div>
                    </div>
                </div>

                <!-- Charts Area -->
                <div class="w-96 p-4 border-l border-gray-700">
                    <h3 class="text-lg font-semibold mb-2 text-purple-300">üìä Analytics</h3>
                    <div class="bg-black bg-opacity-30 rounded-lg h-60 relative">
                        <canvas id="analyticsChart" class="w-full h-full"></canvas>
                        <div id="statisticsPanel" class="hidden absolute inset-0 p-4 text-sm overflow-auto">
                            <!-- Statistics will be displayed here -->
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let scene, camera, renderer, controls;
        let cubeData = [];
        let rawData = [];
        let filteredData = [];
        let currentChart = null;
        let cubeGroup;
        let selectedCubes = [];

        // Initialize the application
        function init() {
            initThreeJS();
            setupEventListeners();
            generateSampleData(); // Start with sample data
        }

        // Initialize Three.js scene
        function initThreeJS() {
            const container = document.getElementById('cubeContainer');
            
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000510);
            
            // Camera setup
            camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);
            
            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0x404040, 0.4);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(10, 10, 5);
            directionalLight.castShadow = true;
            scene.add(directionalLight);
            
            // Mouse controls
            setupMouseControls();
            
            // Start render loop
            animate();
        }

        // Setup mouse controls for 3D interaction
        function setupMouseControls() {
            let mouseDown = false;
            let mouseX = 0;
            let mouseY = 0;
            let targetRotationX = 0;
            let targetRotationY = 0;
            let currentRotationX = 0;
            let currentRotationY = 0;

            const container = renderer.domElement;

            container.addEventListener('mousedown', (event) => {
                mouseDown = true;
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            container.addEventListener('mousemove', (event) => {
                if (!mouseDown) return;
                
                const deltaX = event.clientX - mouseX;
                const deltaY = event.clientY - mouseY;
                
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                
                mouseX = event.clientX;
                mouseY = event.clientY;
            });

            container.addEventListener('mouseup', () => {
                mouseDown = false;
            });

            container.addEventListener('wheel', (event) => {
                camera.position.z += event.deltaY * 0.01;
                camera.position.z = Math.max(5, Math.min(50, camera.position.z));
            });

            container.addEventListener('click', (event) => {
                if (!mouseDown) {
                    handleCubeClick(event);
                }
            });

            // Update camera rotation
            function updateCameraRotation() {
                currentRotationX += (targetRotationX - currentRotationX) * 0.1;
                currentRotationY += (targetRotationY - currentRotationY) * 0.1;
                
                const radius = camera.position.length();
                camera.position.x = radius * Math.sin(currentRotationY) * Math.cos(currentRotationX);
                camera.position.y = radius * Math.sin(currentRotationX);
                camera.position.z = radius * Math.cos(currentRotationY) * Math.cos(currentRotationX);
                
                camera.lookAt(0, 0, 0);
                
                requestAnimationFrame(updateCameraRotation);
            }
            updateCameraRotation();
        }

        // Handle cube click for selection
        function handleCubeClick(event) {
            const rect = renderer.domElement.getBoundingClientRect();
            const mouse = new THREE.Vector2();
            mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            if (cubeGroup) {
                const intersects = raycaster.intersectObjects(cubeGroup.children);
                if (intersects.length > 0) {
                    const cube = intersects[0].object;
                    selectCube(cube);
                }
            }
        }

        // Select/deselect cube
        function selectCube(cube) {
            if (selectedCubes.includes(cube)) {
                // Deselect
                selectedCubes = selectedCubes.filter(c => c !== cube);
                cube.material.emissive.setHex(0x000000);
            } else {
                // Select
                selectedCubes.push(cube);
                cube.material.emissive.setHex(0x444444);
            }
            
            updateDataTable();
        }

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        // Generate sample data
        function generateSampleData() {
            rawData = [];
            const categories = ['Electronics', 'Clothing', 'Books', 'Home', 'Sports'];
            const regions = ['North', 'South', 'East', 'West', 'Central'];
            const quarters = ['Q1', 'Q2', 'Q3', 'Q4'];
            const years = ['2022', '2023', '2024'];

            for (let i = 0; i < 500; i++) {
                rawData.push({
                    Category: categories[Math.floor(Math.random() * categories.length)],
                    Region: regions[Math.floor(Math.random() * regions.length)],
                    Quarter: quarters[Math.floor(Math.random() * quarters.length)],
                    Year: years[Math.floor(Math.random() * years.length)],
                    Sales: Math.floor(Math.random() * 10000) + 1000,
                    Units: Math.floor(Math.random() * 100) + 10,
                    Profit: Math.floor(Math.random() * 5000) + 500
                });
            }

            filteredData = [...rawData];
            updateDataInfo();
            populateDimensionSelectors();
            updateDataTable();
            showNotification('Sample data generated successfully!', 'success');
        }

        // Handle CSV file upload
        document.getElementById('csvFile').addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (!file) return;

            Papa.parse(file, {
                header: true,
                dynamicTyping: true,
                skipEmptyLines: true,
                complete: function(results) {
                    rawData = results.data;
                    filteredData = [...rawData];
                    updateDataInfo();
                    populateDimensionSelectors();
                    updateDataTable();
                    showNotification('CSV file loaded successfully!', 'success');
                },
                error: function(error) {
                    showNotification('Error loading CSV file: ' + error.message, 'error');
                }
            });
        });

        // Update data info panel
        function updateDataInfo() {
            const info = document.getElementById('dataInfo');
            if (rawData.length === 0) {
                info.innerHTML = 'No data loaded.';
                return;
            }

            const columns = Object.keys(rawData[0]);
            info.innerHTML = `
                <div class="text-sm">
                    <div><strong>Records:</strong> ${rawData.length.toLocaleString()}</div>
                    <div><strong>Columns:</strong> ${columns.length}</div>
                    <div class="mt-2"><strong>Fields:</strong></div>
                    <div class="text-xs text-gray-400 mt-1">${columns.join(', ')}</div>
                </div>
            `;
        }

        // Populate dimension selectors
        function populateDimensionSelectors() {
            if (rawData.length === 0) return;

            const columns = Object.keys(rawData[0]);
            const stringColumns = columns.filter(col => typeof rawData[0][col] === 'string');
            const numericColumns = columns.filter(col => typeof rawData[0][col] === 'number');

            const selectors = ['xDimension', 'yDimension', 'zDimension'];
            selectors.forEach(selectorId => {
                const selector = document.getElementById(selectorId);
                selector.innerHTML = '<option value="">Select dimension...</option>';
                stringColumns.forEach(col => {
                    const option = document.createElement('option');
                    option.value = col;
                    option.textContent = col;
                    selector.appendChild(option);
                });
            });

            const measureSelector = document.getElementById('measure');
            measureSelector.innerHTML = '<option value="">Select measure...</option>';
            numericColumns.forEach(col => {
                const option = document.createElement('option');
                option.value = col;
                option.textContent = col;
                measureSelector.appendChild(option);
            });

            // Set default values
            if (stringColumns.length >= 3 && numericColumns.length >= 1) {
                document.getElementById('xDimension').value = stringColumns[0];
                document.getElementById('yDimension').value = stringColumns[1];
                document.getElementById('zDimension').value = stringColumns[2] || stringColumns[0];
                document.getElementById('measure').value = numericColumns[0];
            }

            createFilterControls();
        }

        // Create filter controls
        function createFilterControls() {
            const filterContainer = document.getElementById('filterControls');
            filterContainer.innerHTML = '';

            if (rawData.length === 0) return;

            const columns = Object.keys(rawData[0]);
            const stringColumns = columns.filter(col => typeof rawData[0][col] === 'string');

            stringColumns.forEach(col => {
                const uniqueValues = [...new Set(rawData.map(row => row[col]))];
                
                const filterDiv = document.createElement('div');
                filterDiv.innerHTML = `
                    <label class="block text-xs font-medium mb-1">${col}:</label>
                    <select class="filter-select w-full bg-gray-800 border border-gray-600 rounded px-2 py-1 text-xs" data-column="${col}">
                        <option value="">All</option>
                        ${uniqueValues.map(val => `<option value="${val}">${val}</option>`).join('')}
                    </select>
                `;
                filterContainer.appendChild(filterDiv);
            });

            // Add event listeners to filters
            document.querySelectorAll('.filter-select').forEach(select => {
                select.addEventListener('change', applyFilters);
            });
        }

        // Apply filters to data
        function applyFilters() {
            filteredData = rawData.filter(row => {
                return Array.from(document.querySelectorAll('.filter-select')).every(select => {
                    const column = select.dataset.column;
                    const value = select.value;
                    return !value || row[column] === value;
                });
            });

            updateDataTable();
            if (cubeGroup) updateCube();
            showNotification(`Filtered to ${filteredData.length} records`, 'info');
        }

        // Update 3D cube visualization
        function updateCube() {
            // Clear existing cube
            if (cubeGroup) {
                scene.remove(cubeGroup);
            }

            const xDim = document.getElementById('xDimension').value;
            const yDim = document.getElementById('yDimension').value;
            const zDim = document.getElementById('zDimension').value;
            const measure = document.getElementById('measure').value;

            if (!xDim || !yDim || !zDim || !measure) {
                showNotification('Please select all dimensions and a measure', 'warning');
                return;
            }

            // Aggregate data
            const aggregatedData = aggregateData(filteredData, [xDim, yDim, zDim], measure);
            
            // Create cube group
            cubeGroup = new THREE.Group();
            scene.add(cubeGroup);

            // Get unique values for each dimension
            const xValues = [...new Set(filteredData.map(row => row[xDim]))];
            const yValues = [...new Set(filteredData.map(row => row[yDim]))];
            const zValues = [...new Set(filteredData.map(row => row[zDim]))];

            // Find max value for color scaling
            const maxValue = Math.max(...Object.values(aggregatedData));

            // Create cubes
            xValues.forEach((x, xi) => {
                yValues.forEach((y, yi) => {
                    zValues.forEach((z, zi) => {
                        const key = `${x}_${y}_${z}`;
                        const value = aggregatedData[key] || 0;
                        
                        if (value > 0) {
                            const geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                            
                            // Color based on value
                            const intensity = value / maxValue;
                            const color = new THREE.Color();
                            color.setHSL(0.6 - intensity * 0.6, 1, 0.5 + intensity * 0.3);
                            
                            const material = new THREE.MeshLambertMaterial({ 
                                color: color,
                                transparent: true,
                                opacity: 0.8
                            });
                            
                            const cube = new THREE.Mesh(geometry, material);
                            cube.position.set(
                                (xi - xValues.length/2) * 2,
                                (yi - yValues.length/2) * 2,
                                (zi - zValues.length/2) * 2
                            );
                            
                            cube.userData = { x, y, z, value, key };
                            cubeGroup.add(cube);
                        }
                    });
                });
            });

            // Add axis labels
            updateAxisLabels(xDim, yDim, zDim);
            showNotification('Cube updated successfully!', 'success');
        }

        // Aggregate data for cube visualization
        function aggregateData(data, dimensions, measure) {
            const result = {};
            
            data.forEach(row => {
                const key = dimensions.map(dim => row[dim]).join('_');
                if (!result[key]) result[key] = 0;
                result[key] += row[measure] || 0;
            });
            
            return result;
        }

        // Update axis labels
        function updateAxisLabels(xDim, yDim, zDim) {
            const labelsContainer = document.getElementById('cubeLabels');
            labelsContainer.innerHTML = `
                <div class="dimension-label" style="bottom: 20px; left: 50%; transform: translateX(-50%);">
                    X: ${xDim}
                </div>
                <div class="dimension-label" style="top: 50%; left: 20px; transform: translateY(-50%);">
                    Y: ${yDim}
                </div>
                <div class="dimension-label" style="top: 20px; right: 20px;">
                    Z: ${zDim}
                </div>
            `;
        }

        // Data warehouse operations
        function performSlice() {
            if (!cubeGroup || selectedCubes.length === 0) {
                showNotification('Please select cubes to slice', 'warning');
                return;
            }

            // Hide unselected cubes
            cubeGroup.children.forEach(cube => {
                if (!selectedCubes.includes(cube)) {
                    cube.visible = false;
                }
            });

            showNotification('Slice operation performed', 'success');
        }

        function performDice() {
            const xDim = document.getElementById('xDimension').value;
            const yDim = document.getElementById('yDimension').value;
            
            if (!xDim || !yDim) {
                showNotification('Please select X and Y dimensions for dice operation', 'warning');
                return;
            }

            // Show only a subset of data based on current filters
            applyFilters();
            updateCube();
            showNotification('Dice operation performed', 'success');
        }

        function performDrillDown() {
            // Simulate drill down by adding more detail to the current view
            const currentFilters = {};
            document.querySelectorAll('.filter-select').forEach(select => {
                if (select.value) {
                    currentFilters[select.dataset.column] = select.value;
                }
            });

            if (Object.keys(currentFilters).length === 0) {
                showNotification('Apply some filters first to drill down', 'warning');
                return;
            }

            showNotification('Drill down performed - showing detailed view', 'success');
        }

        function performDrillUp() {
            // Clear all filters to show summary view
            document.querySelectorAll('.filter-select').forEach(select => {
                select.value = '';
            });
            applyFilters();
            showNotification('Drill up performed - showing summary view', 'success');
        }

        function performPivot() {
            // Swap X and Y dimensions
            const xSelect = document.getElementById('xDimension');
            const ySelect = document.getElementById('yDimension');
            const temp = xSelect.value;
            xSelect.value = ySelect.value;
            ySelect.value = temp;
            updateCube();
            showNotification('Pivot operation performed', 'success');
        }

        function performRollUp() {
            // Aggregate to higher level by clearing some filters
            const filterSelects = document.querySelectorAll('.filter-select');
            if (filterSelects.length > 0) {
                filterSelects[filterSelects.length - 1].value = '';
                applyFilters();
                showNotification('Roll up operation performed', 'success');
            }
        }

        // Update data table
        function updateDataTable() {
            const table = document.getElementById('dataTable');
            let dataToShow = filteredData;

            // If cubes are selected, show only related data
            if (selectedCubes.length > 0) {
                const selectedKeys = selectedCubes.map(cube => cube.userData.key);
                const xDim = document.getElementById('xDimension').value;
                const yDim = document.getElementById('yDimension').value;
                const zDim = document.getElementById('zDimension').value;

                if (xDim && yDim && zDim) {
                    dataToShow = filteredData.filter(row => {
                        const key = `${row[xDim]}_${row[yDim]}_${row[zDim]}`;
                        return selectedKeys.includes(key);
                    });
                }
            }

            if (dataToShow.length === 0) {
                table.innerHTML = '<div class="p-4 text-gray-400 text-center">No data to display</div>';
                return;
            }

            const columns = Object.keys(dataToShow[0]);
            const maxRows = 20; // Limit displayed rows for performance
            
            let html = `
                <table class="w-full text-xs">
                    <thead>
                        <tr class="bg-gray-800">
                            ${columns.map(col => `<th class="px-2 py-1 border border-gray-600 font-semibold">${col}</th>`).join('')}
                        </tr>
                                        </thead>
                    <tbody>
                        ${dataToShow.slice(0, maxRows).map(row => `
                            <tr class="border-b border-gray-700 hover:bg-gray-800">
                                ${columns.map(col => `<td class="px-2 py-1 border border-gray-700">${row[col]}</td>`).join('')}
                            </tr>
                        `).join('')}
                        ${dataToShow.length > maxRows ? `
                            <tr>
                                <td colspan="${columns.length}" class="text-center px-2 py-1 text-gray-400">
                                    ... and ${dataToShow.length - maxRows} more rows
                                </td>
                            </tr>
                        ` : ''}
                    </tbody>
                </table>
            `;
            table.innerHTML = html;
        }

        // Show chart
        function showChart(type) {
            const ctx = document.getElementById('analyticsChart').getContext('2d');
            const statisticsPanel = document.getElementById('statisticsPanel');
            
            // Hide statistics panel when showing chart
            statisticsPanel.classList.add('hidden');
            document.getElementById('analyticsChart').style.display = 'block';

            // Destroy existing chart
            if (currentChart) {
                currentChart.destroy();
            }

            // Prepare data
            const measure = document.getElementById('measure').value;
            if (!measure) {
                showNotification('Please select a measure for charting', 'warning');
                return;
            }

            let chartData;
            if (selectedCubes.length > 0) {
                chartData = selectedCubes.map(cube => ({
                    label: cube.userData.key.replace(/_/g, ', '),
                    value: cube.userData.value
                }));
            } else {
                // Aggregate by first dimension
                const xDim = document.getElementById('xDimension').value;
                const aggregated = aggregateData(filteredData, [xDim], measure);
                chartData = Object.entries(aggregated).map(([key, value]) => ({
                    label: key,
                    value: value
                }));
            }

            const labels = chartData.map(item => item.label);
            const data = chartData.map(item => item.value);

            currentChart = new Chart(ctx, {
                type: type,
                data: {
                    labels: labels,
                    datasets: [{
                        label: measure,
                        data: data,
                        backgroundColor: type === 'pie' ? 
                            data.map((_, i) => `hsl(${i * 360 / data.length}, 70%, 60%)`) :
                            `hsla(200, 70%, 60%, 0.8)`,
                        borderColor: type === 'pie' ?
                            data.map((_, i) => `hsl(${i * 360 / data.length}, 70%, 40%)`) :
                            `hsla(200, 70%, 40%, 1)`,
                        borderWidth: 2
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            labels: {
                                color: 'white'
                            }
                        }
                    },
                    scales: type !== 'pie' && type !== 'doughnut' ? {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                color: 'white'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            }
                        },
                        x: {
                            ticks: {
                                color: 'white'
                            },
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            }
                        }
                    } : {}
                }
            });
        }

        // Show statistics
        function showStatistics() {
            const statisticsPanel = document.getElementById('statisticsPanel');
            const analyticsChart = document.getElementById('analyticsChart');
            
            // Hide chart when showing statistics
            analyticsChart.style.display = 'none';
            statisticsPanel.classList.remove('hidden');

            const measure = document.getElementById('measure').value;
            if (!measure || filteredData.length === 0) {
                statisticsPanel.innerHTML = '<div class="text-gray-400">No data available for statistics</div>';
                return;
            }

            const values = filteredData.map(row => row[measure]).filter(v => !isNaN(v));
            const stats = calculateStatistics(values);

            statisticsPanel.innerHTML = `
                <div class="text-sm space-y-2">
                    <h4 class="font-semibold text-blue-300 mb-3">Statistics for ${measure}</h4>
                    <div><strong>Count:</strong> ${stats.count}</div>
                    <div><strong>Sum:</strong> ${stats.sum.toLocaleString()}</div>
                    <div><strong>Mean:</strong> ${stats.mean.toFixed(2)}</div>
                    <div><strong>Median:</strong> ${stats.median.toFixed(2)}</div>
                    <div><strong>Mode:</strong> ${stats.mode}</div>
                    <div><strong>Min:</strong> ${stats.min.toLocaleString()}</div>
                    <div><strong>Max:</strong> ${stats.max.toLocaleString()}</div>
                    <div><strong>Standard Deviation:</strong> ${stats.stdDev.toFixed(2)}</div>
                    <div><strong>Variance:</strong> ${stats.variance.toFixed(2)}</div>
                </div>
            `;
        }

        // Calculate statistics
        function calculateStatistics(values) {
            const sorted = values.sort((a, b) => a - b);
            const count = values.length;
            const sum = values.reduce((a, b) => a + b, 0);
            const mean = sum / count;
            const median = count % 2 === 0 ? 
                (sorted[count/2 - 1] + sorted[count/2]) / 2 : 
                sorted[Math.floor(count/2)];
            
            const frequency = {};
            let maxFreq = 0;
            let mode = 0;
            values.forEach(v => {
                frequency[v] = (frequency[v] || 0) + 1;
                if (frequency[v] > maxFreq) {
                    maxFreq = frequency[v];
                    mode = v;
                }
            });

            const variance = values.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / count;
            const stdDev = Math.sqrt(variance);

            return {
                count,
                sum,
                mean,
                median,
                mode,
                min: Math.min(...values),
                max: Math.max(...values),
                variance,
                stdDev
            };
        }

        // Show notification
        function showNotification(message, type) {
            const notification = document.createElement('div');
            notification.className = `fixed top-4 right-4 px-6 py-3 rounded-lg text-white z-50 transition-all duration-300 transform translate-x-full`;
            
            const colors = {
                success: 'bg-green-600',
                error: 'bg-red-600',
                warning: 'bg-yellow-600',
                info: 'bg-blue-600'
            };
            
            notification.classList.add(colors[type] || colors.info);
            notification.textContent = message;
            
            document.body.appendChild(notification);
            
            // Animate in
            setTimeout(() => {
                notification.classList.remove('translate-x-full');
            }, 100);
            
            // Remove after 3 seconds
            setTimeout(() => {
                notification.classList.add('translate-x-full');
                setTimeout(() => {
                    document.body.removeChild(notification);
                }, 300);
            }, 3000);
        }

        // Setup event listeners
        function setupEventListeners() {
            window.addEventListener('resize', () => {
                const container = document.getElementById('cubeContainer');
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
        }

        // Initialize the application
        init();
    </script>
</body>
</html>